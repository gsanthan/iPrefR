package verify;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

import model.PreferenceMetaData;
import util.FileUtil;
import util.OutputUtil;
import util.StringUtil;

/**
 * ModelChecker is the interface between the preference reasoner in Java and the model checker tool that runs on the OS shell.
 * Provides two methods for verifying models given in the input language of SMV. 
 * One method accepts and verifies an smvFile that contains the model as well as the property to be verified, 
 * and returns a file containing the raw output generated by the model checker.
 * The other method accepts the smvFile containing the model and a separate specFile containing the list of specs to be verified for the model, 
 * and returns a file containing the formatted (true/false) list of verification results for the specs   
 * 
 * @author gsanthan
 *
 */
public class ModelChecker {
	
	/**
	 * Uses the OS shell command to invoke a model checking tool to verify the model given in the smvFile against each spec in specFile using the variable ordering listed in voFile
	 * Note: The variable ordering file is optional (may be specified as null if none is used) 
	 * 
	 * @param command Actual command line (corresponding to the model checker) to be invoked from the OS shell
	 * @param smvFileName File to be model-checked for the specifications given in specFileName
	 * @param specFileName File containing a list of temporal specifications to be verified 
	 * @param voFile Optional variable ordering file (for custom variable ordering)
	 * @return Name of the file that stores the summary list of verification results for specifications given in specFileName 
	 * @throws Exception
	 */
	public String invokeModelChecker(PreferenceMetaData prefMetaData, String command, String smvFileName, String specFileName, String voFile) throws Exception {
		
		//Prepare to verify one spec in specFile at a time for the model in smvFile 
		String[] smvFiles = new String[]{smvFileName};
		if(specFileName != null) {
			smvFiles = prepareSMVFilesForVerification(smvFileName, specFileName, false);
		}
		
		//Verify each prepared file and save the raw output generated by the model checker 
		String[] outputFiles = new String[smvFiles.length];
		for (int i = 0; i < smvFiles.length; i++) {
			outputFiles[i] = invokeModelChecker(prefMetaData, command, smvFiles[i], voFile);
		}
		
		//Format results so that list of verification results (true/false) for the specs in specFile can be consolidated and returned as a single file 
		String formattedOutputFileName = formatNuSMVOutputFiles(outputFiles);
		//Switch the outputFile to the file that contains the consolidated results for all specs in specFile
		prefMetaData.setOutputFile(formattedOutputFileName);
		
		//Note: The raw outputFiles are now no more accessible to the caller; however this may be changed if access to them is necessary 
		return formattedOutputFileName;
	}
	
	/**
	 * Uses the OS shell command to invoke a model checking tool to verify the model and spec(s) given in the smvFile using the variable ordering listed in voFile.
	 * Returns the name of the file that stores the raw (console) output generated by the model checker when the model and spec(s) in smvFile are verified.  
	 * Note: Variable ordering file is optional (may be specified as null if none is used) 
	 * Note: If multiple specs are within the smvFile, then the outputFile may contain the results of verifying all the specs as formatted by the model checker
	 * 
	 * @param command Actual command line (corresponding to the model checker) to be invoked from the OS shell
	 * @param smvFile File to be model-checked for the specification given in the same file
	 * @param voFile Optional variable ordering file (for custom variable ordering)
	 * @return Name of the file that stores the raw (console) output generated by the model checker when the model and spec(s) in smvFile are verified  
	 * @throws Exception
	 */
	public String invokeModelChecker(PreferenceMetaData prefMetaData, String command, String smvFile, String voFile) throws Exception {
		
		long timer = System.currentTimeMillis();
		
		//Consider the variable order given as a list in voFile (optional) 
		if(voFile != null && voFile.trim().length()!=0) {
			//The "-i" option in SMV allows for custom variable ordering to be specified in a separate file  
			//Note: Need to check if this works for NuSMV, CadenceSMV, etc.
			command = command + " -i " + voFile + " ";
		}
		
		command = command + smvFile ;
		Process proc =null;
		String outputFile;
		try {
			
		//Invoke the Command from the OS shell using Java Runtime 
		proc = Runtime.getRuntime().exec(command);
		BufferedReader output = new BufferedReader(new InputStreamReader(proc.getInputStream()));
		BufferedReader error = new BufferedReader(new InputStreamReader(proc.getErrorStream()));
		
		outputFile = prefMetaData.getOutputFile(); 
		BufferedWriter w = FileUtil.openFile(outputFile); 
		String nextLine;
		
		//Gobble and save the output and error streams 
		while((nextLine = output.readLine()) != null) {
			FileUtil.writeLineToFile(w, nextLine);
		} 
		while((nextLine = error.readLine()) != null) {
			FileUtil.writeLineToFile(w, nextLine);
		}
		
		//Record the local (Java) time taken for verification;
		//this should be slightly more than what the model checker reports
		String time = System.currentTimeMillis() - timer + " ms";
		FileUtil.writeLineToFile(w, time);
		
		FileUtil.closeFile(w);
		} finally {
			//Close all the opened streams to ensure not too many files are open at the same time 
			if(proc != null) {
				proc.getInputStream().close();
				proc.getOutputStream().close();
				proc.getErrorStream().close();
				proc.destroy();
			}
		}
		
		return outputFile;
	}
	
	/**
	 * Prepares multiple specs for verification against the model in smvFile.
	 * Makes a copy of the original smv file for each spec in specFile; then adds the spec to this copy; 
	 * and finally saves the list of smv files with the individual specs included.
	 * Returns an array of SMV file names containing the saved models with individual specs.
	 * 
	 * @param smvFile File to be model-checked for the specifications given in specFileName
	 * @param specFile File containing a list of temporal specifications to be verified 
	 * @param AGstyleSpec Whether the property is specified as an AG property (used for smv2qbf)
	 * @return Array of SMV file names containing the saved models with individual specs
	 * @throws IOException
	 */
	public String[] prepareSMVFilesForVerification(String smvFile, String specFile, boolean AGstyleSpec) throws IOException {
		List<String> smvFiles = new ArrayList<String>();
		BufferedReader reader = new BufferedReader (new FileReader(specFile));
		String nextLine = null;
		int specCount = 0;

		//Make a copy of the original smv file for each spec in specFile; add the spec to this copy; and finally save the list of smv files 
		while((nextLine = reader.readLine())!=null) {
			
			//Make a copy of the original smv file
			String currentSmvFile = smvFile.substring(0, smvFile.length()-4).concat("-spec"+(++specCount)+".smv");
			smvFiles.add(currentSmvFile);
			FileUtil.copyFile(new File(smvFile), new File(currentSmvFile));
			
			//Extract each spec from the spec file
			int beginIndex = "SPEC (".length();
			int endIndex = nextLine.indexOf(" -> ");
			String initAssignmentForSpec = nextLine.substring(beginIndex, endIndex);
			
			//Change the spec format from a state formula to a init assignment, 
			//so that this is the start state for the current smv file for this particular spec
			String[] literals = initAssignmentForSpec.split(" & ");
			String temp = "";
			for (int i = 0; i < literals.length; i++) {
				if(literals[i].contains("=")) {
					if(literals[i].endsWith("=0")) {
						temp += "init("+literals[i].substring(0,1)+"):=0;";
					} else {
						temp += "init("+literals[i].substring(0,1)+"):=1;";
					}
				} else if(literals[i].startsWith("!")) {
					temp += "init("+literals[i].substring(1)+"):=0;";
				} else {
					temp += "init("+literals[i]+"):=1;";
				}
			}
			OutputUtil.println(temp);
			
			//Append this init and spec to the current spec file and save it
			FileUtil.appendLineToFile(currentSmvFile, temp);
			if(AGstyleSpec) {
				beginIndex = nextLine.indexOf("->") + 2;
				endIndex = nextLine.length()-1;
				String agStyleQuery = "SPEC (" + nextLine.substring(beginIndex, endIndex);
				FileUtil.appendLineToFile(currentSmvFile, agStyleQuery);
			} else {
				FileUtil.appendLineToFile(currentSmvFile, nextLine);
			}
		}
		return smvFiles.toArray(new String[0]);
	}
	
	/**
	 * Extracts the verification results (true/false) from the raw outputs generated from multiple verification runs.
	 * Verification results are enumerated and saved.  
	 * 
	 * @param outputFileNames
	 * @return Name of the file containing enumerated list of verification results extracted from outputFileNames 
	 * @throws IOException
	 */
	public String formatNuSMVOutputFiles(String[] outputFileNames) throws IOException {
		float cumulatedProcTime = 0;
		String procTimes = "";
		
		String formattedOutputFileName = outputFileNames[0].substring(0, outputFileNames[0].length()-15)+"-formatted.txt";
		BufferedWriter w = FileUtil.openFile(formattedOutputFileName);
		int lineNum = 0;
		for (int i = 0; i < outputFileNames.length; i++) {
			BufferedReader reader = new BufferedReader (new FileReader(outputFileNames[i]));
			String nextLine;
			
			while((nextLine = reader.readLine()) != null) {
				if(nextLine.endsWith("true")) {
					//Parse verification result
					String resultFormatter = StringUtil.padWithSpace((lineNum+1)+". ",7);
					FileUtil.writeLineToFile(w, resultFormatter + "true");
					lineNum++;
				} else if(nextLine.endsWith("false")) {
					//Parse verification result
					String resultFormatter = StringUtil.padWithSpace((lineNum+1)+". ",7);
					FileUtil.writeLineToFile(w, resultFormatter + "false");
					lineNum++;
				} else if(nextLine.endsWith("ms")) {
					//Parse running time, e.g., processor time: 0.09 s
					float runningTime = Float.parseFloat(nextLine.substring(0,nextLine.length()-2));
					cumulatedProcTime = cumulatedProcTime + runningTime;
					procTimes += "," + runningTime/1000.0;
				} 
			} 
			reader.close();
		}
		
		//Variable cumulatedProcTime contains the aggregate time for running all specs
		cumulatedProcTime = cumulatedProcTime/5;
		//Convert milliseconds to seconds
		cumulatedProcTime = cumulatedProcTime/1000;
		
		//Log performance statistics 
		String performance = "   Avg. Processor Time: "+StringUtil.padWithRightSpace(""+cumulatedProcTime,16)+
		"   Proc Times: "+StringUtil.padWithRightSpace(""+procTimes,50);
		FileUtil.logResult(performance);
		FileUtil.closeFile(w);
		
		return formattedOutputFileName;
	}
}

